# Grammar

NProg     ::= [Statement]
Statement ::= NDeclare
            | NAssign
            | NRead
            | NPrint
            | NScope
            | NIfElse
            | NWhile
            | NStore

NScope    ::= `{` [Statement] `}`

Expr      ::= Term 
            | BinExpr

# TODD: maybe replace Expr to Term where it is

Term      ::= id
            | int
            | char
            | (Expr)
            | NLoad

BinExpr   ::= Expr BinOp Expr

NIfElse   ::= `if` Expr NScope {`else` NScope}

NWhile    ::= `while` Expr NScope  

NDeclare  ::= `let` id {`=` Expr} `;`
NAssign   ::= id = Expr `;`
NPrint    ::= `print` Expr `;`
NRead     ::= `read` id `;`

NLoad     ::= `@` Term
NNot      ::= `!` Term
NStore    ::= `@` Term `=` Expr `;`

!a

a and b => i if all 1. 0 if any 0

a b
^
>>[-]<<
[ at a
    > at b
    [
        >>+<<
        [-]
    ]
    <
    [-]
]
>>[-<<+>>]<<

a or b: 1 if any 1. 0 if all 0

a b
^

>>[-]++<<
[ at a
    >>-<<
    > at b
    [
        >>-<<
        [-]
    ]
    <
    [-]
]
>>[-<<+>>]<<



# Macros

MULTIPLICATION = >>[-]>[-]<<<[->>+<<]>[->[-<<+>>>+<]>[-<+>]<<]<

>>>>>[-]<<<<<

a b c _ _ _ _
^

[->>>+>>+<<<<<]>>>>>[-<<<<<+>>>>>]<<<<<

a b c a`_ _ _
^

> [->>>+>+<<<<]>>>>[-<<<<+>>>>]<<<<<

a b c a`b`_ _
^
>>[-]<<[>[>+<[-]]<[-]]

0 0 & a`b`_ _
^

>>[

    
]

f"{to(cond_addr)}[\n{gen_scope(node.body)}\n{gen_expr(node.cond)}{store(cond_addr)}{to(cond_addr)}]"
>>>>>> skip heap
[-]++++++ push 6
<[-]>[-<+>] store
>[-]+++++push 5
<[-]>[-<+>] store
[-]<<[->>+>+<<<]>>>[-<<<+>>>] top a
[-]<<[->>+>+<<<]>>>[-<<<+>>>] top b

[-]<<[>[>+<[-]]<[-]]>>[-<<+>>] a && b
<<[ while
    >[-]<<<[->>>+>+<<<<]>>>>[-<<<<+>>>>] top a
    [-]+ push 1 
    [-<->] sub from a
    <<<<[-]>>>[-<<<+>>>] store a
    [-]<<[->>+>+<<<]>>>[-<<<+>>>] top b
    [-]+ push 1
    [-<->] sub from b
    <<<[-]>>[-<<+>>] store b
    [-]<<<[->>>+>+<<<<]>>>>[-<<<<+>>>>] top a
    [-]<<<[->>>+>+<<<<]>>>>[-<<<<+>>>>] top b
    [-]<<[>[>+<[-]]<[-]]>>[-<<+>>] a && b
    <<<[-]>[-<+>] store a&&b
<] endwhile

a b 0
    ^
    
a b res
0 0 ==
0 1 <
1 0 >
1 1 not possible

> a
< b
>= !a
<= !b

ab0
  ^

`>` b
<<[-]>[<+>[-]] at b

`<` a
<[-]<[->+<]>[<+>[-]] at b

`<=` !b
<<[-]+>[<[-]>[-]] at b

`>=` !a
<[-]<[->+<]+>[<[-]>[-]] at b





-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-
>>>>>> skip heap
[-]++++++ push 6
<[-]>[-<+>] store
>[-]+++++push 5
<[-]>[-<+>] store

[-]>[-]<<<[->>+>+<<<]>>>[-<<<+>>>] top a
[-]>[-]<<<[->>+>+<<<]>>>[-<<<+>>>] top b

[-]<<[>[>+<[-]]<[-]]>>[-<<+>>] a && b
<<[ while
    <<->->>
    [-]>[-]<<<<[->>>+>+<<<<]>>>>[-<<<<+>>>>] top a
    [-]>[-]<<<<[->>>+>+<<<<]>>>>[-<<<<+>>>>] top b
    [-]<<[>[>+<[-]]<[-]]>>[-<<+>>] a && b
    <<<[-]>[-<+>] store a&&b
<] endwhile
    
    
[-]<[->+>+<<]>>[-<<+>>] top b
[-] push 0
<[->-<]+>[<[-]>[-]] b==0
<<<[-]>>[-<<+>>] store a

# Ideas

Vars{id:: addr}



macros[]
put: <obj>,
Array.put: <obj>

vid.mid -> f"{vars[vid].type}.{mid}" 

struct Array{
    ptr,
    len
    
    macro put(addr, val){
        *(ptr+addr)=val;
    }
    
}

let arr: Array = {0, 8};
arr.put(4, 0)

macro put(arr, addr, val){
    *(arr+addr) = val;
}


put(arr, 4, 0);


# while

gen_cond to(cond)[  *body*  gen_cond store(cond) to(cond)]

let arr = 0;
const arr_len = 5;

let i = arr_len;
while i {
    &(arr+i) <- i;
    i = i - 1;
}

i = arr_len;
while i {
    print(&i)
}

42 @  ->  value of heap[42] 

42 69 !   -> store 69 at heap[42]


a_a_a_a0....i..
            ^
to(i) > [-] > [-] <<
a_a_a_a0....i00
            ^
[- > + to(hp-2) + to(i)]
a_a_aia0****0i0
            ^
to(hp-2)
a_a_aia0****0i0
     ^
[[-<<+>>]+<<-]+
a_aia1a0****0i0
   ^
a_a1a1a0****0i0
   ^
>[
    -<
    [->>]
    <<
a_a_a_a0****0i0
     ^
    to(i) +
    >
a_a_a_a0****1i0
             ^
    [->+to(hp-2)+to(i+1)]
a_a_aia0****00i
             ^
    >
    [-<+>]
a_a_aia0****0i0
              ^
    to(hp-2)
a_a_aia0****0i0
     ^
    [[-<<+>>]+<<-]+
a_aia1a0****0i0
   ^
a_a1a1a0****0i0
   ^
>]<[->>]<<
