# Grammar

NProg     ::= [Statement]
Statement ::= NDeclare
            | NAssign
            | NRead
            | NPrint
            | NScope
            | NIfElse
            | NWhile
            | NStore

NScope    ::= `{` [Statement] `}`

Expr      ::= Term 
            | BinExpr

# TODD: maybe replace Expr to Term where it is

Term      ::= id
            | int
            | char
            | (Expr)
            | NLoad

BinExpr   ::= Expr BinOp Expr

NIfElse   ::= `if` Expr NScope {`else` NScope}

NWhile    ::= `while` Expr NScope  

NDeclare  ::= `let` id {`=` Expr} `;`
NAssign   ::= id = Expr `;`
NPrint    ::= `print` Expr `;`
NRead     ::= `read` id `;`

NLoad     ::= `&` Term
NNot      ::= `!` Term
NStore    ::= `&` Term `=` Expr `;`


# Macros

MULTIPLICATION = >>[-]>[-]<<<[->>+<<]>[->[-<<+>>>+<]>[-<+>]<<]<



# Ideas

Vars{id:: addr}



macros[]
put: <obj>,
Array.put: <obj>

vid.mid -> f"{vars[vid].type}.{mid}" 

struct Array{
    ptr,
    len
    
    macro put(addr, val){
        *(ptr+addr)=val;
    }
    
}

let arr: Array = {0, 8};
arr.put(4, 0)

macro put(arr, addr, val){
    *(arr+addr) = val;
}


put(arr, 4, 0);





python??? Library for command line arguments

# while

gen_cond to(cond)[  *body*  gen_cond store(cond) to(cond)]

let arr = 0;
const arr_len = 5;

let i = arr_len;
while i {
    &(arr+i) <- i;
    i = i - 1;
}

i = arr_len;
while i {
    print(&i)
}

42 @  ->  value of heap[42] 

42 69 !   -> store 69 at heap[42]


a_a_a_a0....i..
            ^
to(i) > [-] > [-] <<
a_a_a_a0....i00
            ^
[- > + to(hp-2) + to(i)]
a_a_aia0****0i0
            ^
to(hp-2)
a_a_aia0****0i0
     ^
[[-<<+>>]+<<-]+
a_aia1a0****0i0
   ^
a_a1a1a0****0i0
   ^
>[
    -<
    [->>]
    <<
a_a_a_a0****0i0
     ^
    to(i) +
    >
a_a_a_a0****1i0
             ^
    [->+to(hp-2)+to(i+1)]
a_a_aia0****00i
             ^
    >
    [-<+>]
a_a_aia0****0i0
              ^
    to(hp-2)
a_a_aia0****0i0
     ^
    [[-<<+>>]+<<-]+
a_aia1a0****0i0
   ^
a_a1a1a0****0i0
   ^
>]<[->>]<<

macro foo(a, b){
    @a*@b
}

macro bar(a, b){
    @a = @b;
}

macro main{
    let a = 2;
    let b = 42;
    foo(&)
}
